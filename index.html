<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>chenhy&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="keep learning">
<meta property="og:type" content="website">
<meta property="og:title" content="chenhy's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="chenhy's blog">
<meta property="og:description" content="keep learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chenhy's blog">
<meta name="twitter:description" content="keep learning">
  
    <link rel="alternative" href="/atom.xml" title="chenhy&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://odizoogtm.bkt.clouddn.com/Octocat_GitHub.png?imageView2/2/w/300" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">chenhy</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/essay">随笔</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/chhy2009" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
								<a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Github-pages/" style="font-size: 10px;">Github pages</a> <a href="/tags/Linux-signal/" style="font-size: 10px;">Linux signal</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/Markdown/" style="font-size: 20px;">Markdown</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/centos/" style="font-size: 10px;">centos</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/keepalive/" style="font-size: 10px;">keepalive</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/openssl/" style="font-size: 10px;">openssl</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/software/" style="font-size: 10px;">software</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/visual-studio/" style="font-size: 10px;">visual studio</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/codingcs">我的csdn博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">程序员，编程爱好者</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">chenhy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/http://odizoogtm.bkt.clouddn.com/Octocat_GitHub.png?imageView2/2/w/300" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">chenhy</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/essay">随笔</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/chhy2009" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-high-performance-sql-md" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/12/high-performance-sql-md/" class="article-date">
  	<time datetime="2017-04-12T00:22:18.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/high-performance-sql-md/">high_performance_sql.md</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库结构图"><span class="toc-text">数据库结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为排序使用索引扫描"><span class="toc-text">为排序使用索引扫描</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查询优化"><span class="toc-text">查询优化</span></a></li></ol>
</div>

         
        <h2 id="数据库结构图"><a href="#数据库结构图" class="headerlink" title="数据库结构图"></a>数据库结构图</h2><p>存储引擎层</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>B-Tree索引<br>hash索引<br>innodDB中的自适应hash索引<br>使用where语句手动定义hash函数，增加查找速度，例子如url查找</p>
<p>select id from url where url=”www.mysqlcom” and url_crc=CRC32(“<a href="http://www.mysql.com" target="_blank" rel="external">http://www.mysql.com</a>“);</p>
<p>这种方法的一个缺点就是要维护哈希值，可以使用触发器进行维护：<br>create table pseudohash(<br>    id int unsigned NOT NULL auto_increment,<br>    url varchar(255) NOT NULL,<br>    url_crc int unsigned NO NULL DEFAULT 0,<br>    primary key(id)<br>);  </p>
<p>创建触发器：</p>
<p>可以使用的伪hash函数如下：<br>CRC32  right(MD5(),n)  left(MD5(), n)<br>像md5,sha1之类的函数返回的值太长，可以取其结果的部分值进行说明  </p>
<p>sql 分隔符，delimiter关键字？</p>
<h3 id="为排序使用索引扫描"><a href="#为排序使用索引扫描" class="headerlink" title="为排序使用索引扫描"></a>为排序使用索引扫描</h3><p>按照索引对结果进行排序，只有当索引的顺序和order by子句中的顺序完全一致，并且所有列的方向（升序或降序）一样才可以。如果查询联接了多个表，只有在order by子句的所有列引用的是第一个表才可以。查找查询中的order by子句也有同样的局限：它要使用索引的最左前缀，在其他所有情况下，mysql使用文件排序。</p>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>group by：如果运行了很多很长的聚合查询以生成汇总，那么磁盘使用会因支持group by查询的覆盖索引而得益。<br>的使用</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-disscuss-group" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/15/disscuss-group/" class="article-date">
  	<time datetime="2017-03-15T15:18:25.000Z" itemprop="datePublished">2017-03-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/15/disscuss-group/">社区</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#图灵社区"><span class="toc-text">图灵社区</span></a></li></ol>
</div>

         
        <h2 id="图灵社区"><a href="#图灵社区" class="headerlink" title="图灵社区"></a>图灵社区</h2><p><a href="http://www.ituring.com.cn" target="_blank" rel="external">图灵社区</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-design-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/13/design-pattern/" class="article-date">
  	<time datetime="2017-03-13T14:58:37.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/design-pattern/">（转）GoF的23个经典设计模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建型"><span class="toc-text">创建型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构型"><span class="toc-text">结构型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行为型"><span class="toc-text">行为型</span></a></li></ol>
</div>

         
        <p><img src="/img/gof23_dp.png" alt="img"></p>
<p>以文本和思维导图的方式简明扼要的介绍了GoF的23个经典设计模式，可当成学习设计模式的一个小手册，偶尔看一下，说不定会对大师的思想精髓有新的领悟。</p>
<p>GoF(“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson &amp; John Vlissides)</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>创建型模式(5个)</strong>：单例模式、原型模式、建造者模式、工厂模式、抽象工厂模式。</p>
<p><strong>结构型模式(7个)</strong>：桥接模式、外观模式、组合模式、装饰模式、适配器模式、代理模式、享元模式。 </p>
<p><strong>行为型模式(11个)</strong>：迭代器模式、解释器模式、观察者模式、中介者模式、访问者模式、备忘录模式、状态模式、策略模式、模版方法模、命令模式、职责链模式式。</p>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><ul>
<li><p><strong>Singleton（单例模式）</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </p>
</li>
<li><p><strong>Prototype（原型模式）</strong>：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 </p>
</li>
<li><p><strong>Builder（建造者模式）</strong>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 </p>
</li>
<li><p><strong>Factory Method(工厂模式)</strong>：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。 </p>
</li>
<li><p><strong>Abstract Factory（抽象工厂模式）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</li>
</ul>
<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><ul>
<li><p><strong>Bridge（桥接模式）</strong>：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 </p>
</li>
<li><p><strong>Facade（外观模式）</strong>：为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 </p>
</li>
<li><p><strong>Composite(组合模式)</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 </p>
</li>
<li><p><strong>Decorator(装饰模式)</strong>：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。 </p>
</li>
<li><p><strong>Adapter（适配器模式）</strong>：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 </p>
</li>
<li><p><strong>Proxy（代理模式）</strong>：为其他对象提供一个代理以控制对这个对象的访问。 </p>
</li>
<li><p><strong>Flyweight（享元模式）</strong>：运用共享技术有效地支持大量细粒度的对象。</p>
</li>
</ul>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><ul>
<li><p><strong>Iterator（迭代器模式）</strong>：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 </p>
</li>
<li><p><strong>Interpreter（解析器模式）</strong>：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。 </p>
</li>
<li><p><strong>Observer（观察者模式）</strong>：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。 </p>
</li>
<li><p><strong>Mediator（中介者模式）</strong>：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 </p>
</li>
<li><p><strong>Visitor（访问者模式）</strong>：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 </p>
</li>
<li><p><strong>Memento（备忘录模式）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。 </p>
</li>
<li><p><strong>State（状态模式）</strong>：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。 </p>
</li>
<li><p><strong>Strategy（策略模式）</strong>：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。 </p>
</li>
<li><p><strong>Template Method（模板方法模式）</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 </p>
</li>
<li><p><strong>Command（命令模式）</strong>：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 </p>
</li>
<li><p><strong>Chain of Responsibility（职责链模式）</strong>：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p>
</li>
</ul>
<p>转载链接：<a href="http://www.cnblogs.com/springworks/p/3459458.html" target="_blank" rel="external">GoF的23个经典设计模式</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/设计模式/">设计模式</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-syslog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/08/syslog/" class="article-date">
  	<time datetime="2017-03-08T13:38:06.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/syslog/">syslog日志</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#syslog日志格式"><span class="toc-text">syslog日志格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS编程"><span class="toc-text">TLS编程</span></a></li></ol>
</div>

         
        <h2 id="syslog日志格式"><a href="#syslog日志格式" class="headerlink" title="syslog日志格式"></a>syslog日志格式</h2><p>header(信息长度mes_len) “<pri>SYSLOGPRO_VERSION TIMESTAMP FQDN/IP APP_NAME PROC_ID(pid) MSGID STRUCTURED_DATA BOM(\xEF\BB\xBF) MSG”  </pri></p>
<ul>
<li>header: “”里面的信息长度  </li>
<li>PRI=logFacility * 8 + logLevel    </li>
<li>SYSLOGPRO_VERSION: syslog protocol version(such as: 1)    </li>
<li>TIMESTAMP:时间戳 如，2017-01-01T00:00:00.000000+02:00  (最多精确到us)  </li>
<li>STRUCTURED_DATA:结构化数据  </li>
<li>BOM:指出编码为UTF8  </li>
<li>MSG:信息主体  </li>
</ul>
<h2 id="TLS编程"><a href="#TLS编程" class="headerlink" title="TLS编程"></a>TLS编程</h2><p>利用openssl库提供的ssl编程接口，可以容易实现TLS交互，其客户端编程步骤如下：  </p>
<ol>
<li>创建socket，调用connect连接服务端  </li>
<li>调用SSL_CTX_new创建SSL context，调用SSL_set_verify设置证书校验回调函数，可以定制一些特殊的校验场景；SSL_set_cipher_list设置客户端的加密套件等操作  </li>
<li>调用SSL_new创建SSL结构，调用SSL_set_fd,SSL_connect进行TLS握手，然后调用  SSL_set_connect_state 设置ssl工作在客户端模式  </li>
<li>调用SSL_read/SSL_write进行读写操作  </li>
<li>交互完成后，调用SSL_shutdown、SSL_free等进行清理工作  </li>
</ol>
<p>详细例子可以参考openssl中的apps/s_server.c s_client.c的实现  </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-visual-2010-quickButton" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/05/visual-2010-quickButton/" class="article-date">
  	<time datetime="2017-03-05T02:28:04.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/05/visual-2010-quickButton/">visual studio快捷键</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    
</div>

         
        <ul>
<li>ctrl+’-‘:回到上一个位置，相当于vim的ctrl+’o’  </li>
<li>ctrl+shift+’-‘:回到之后的位置，ctrl+’-‘的逆操作  </li>
<li>F12:转到定于  </li>
<li>光标停留在需要查找的词上面，使用快捷键ctrl+F3可以跳转到下一个相同的词；使用shift+F3可以往上查找</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/visual-studio/">visual studio</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-yaa-and-lex" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/26/yaa-and-lex/" class="article-date">
  	<time datetime="2017-02-26T02:00:08.000Z" itemprop="datePublished">2017-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/26/yaa-and-lex/">yaa and lex</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    
</div>

         
        <p>lex就是语法扫描器，yacc就是语法分析器。<br>lex 源文件中的yywrap函数是必须的，因为给出了这个函数实现之后可以不需要依赖flex库了。<br>yywrap直接返回1，表示输入已经结束了。<br>基本的lex文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%&#123;<span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">(<span class="keyword">void</span>)</span></span>;%&#125;%%%%<span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure>
<p>基本的yacc文件:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%&#123;<span class="function"><span class="keyword">void</span> <span class="title">yyerror</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *s</span>)</span>;%&#125;%%program:	;%%<span class="function"><span class="keyword">void</span> <span class="title">yyerror</span>(<span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *s</span>)</span>&#123;&#125;<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)%%</span>&#123;</div><div class="line">yyparse();<span class="keyword">return</span> <span class="number">0</span>;&#125;</div></pre></td></tr></table></figure>
<p>yacc文件中的代码被%%分成3个部分，第一部分表示要写入到c文件的c/c++代码，由%{和%}括起来；中间部分是yacc的语法规则；第三部分是可以直接写入c/c++代码，不需要任何的修饰。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-tcp-keepalive" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/23/tcp-keepalive/" class="article-date">
  	<time datetime="2017-02-23T14:50:10.000Z" itemprop="datePublished">2017-02-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/23/tcp-keepalive/">tcp_keepalive编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
         
        <p>KeepAlive机制中设置的参数包含如下：  </p>
<ul>
<li>SO_KEEPALIVE  设置套接字的keepalive状态</li>
<li>TCP_KEEPIDLE  关闭一个非活跃连接之前进行探测的最大时长，默认值为2h</li>
<li>TCP_KEEINTVL  两次探测的时间间隔，默认值为150s，即每次间隔75s</li>
<li>TCP_KEEPCNT 关闭一个非活跃连接之前进行的最大操作次数，默认值为8<br>这些默认值位于/proc/sys/net/ipv4目录下。<br>程序实现时可以通过setsockopt函数进行相关设置，代码段如下：  </li>
</ul>
<pre><code class="c"><span class="comment">//设置socket为TCP_KEEPALIVE</span>
<span class="keyword">int</span> keepAlive = <span class="number">1</span>；
setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span>*)&amp;keepAlive, <span class="keyword">sizeof</span>(keepAlive));
<span class="keyword">int</span> keepIdle = <span class="number">6</span>;
<span class="keyword">int</span> keepInterval = <span class="number">5</span>;
<span class="keyword">int</span> keepCount = <span class="number">3</span>;
setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span> *)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle));
setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval)); 
setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount));
</code></pre>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/keepalive/">keepalive</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-tcp-status" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/23/tcp-status/" class="article-date">
  	<time datetime="2017-02-23T14:45:11.000Z" itemprop="datePublished">2017-02-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/23/tcp-status/">tcp释放连接的close_wait, FIN_WAIT2, TIME_WAIT大量存在的原因</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#存在close-wait的原因"><span class="toc-text">存在close_wait的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存在FIN-WAIT2的原因"><span class="toc-text">存在FIN_WAIT2的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存在TIME-WAIT的原因"><span class="toc-text">存在TIME_WAIT的原因</span></a></li></ol>
</div>

         
        <h2 id="存在close-wait的原因"><a href="#存在close-wait的原因" class="headerlink" title="存在close_wait的原因"></a>存在close_wait的原因</h2><p>close_wait这个状态存在于服务端，当服务端发送FIN（之前客户端已经发送过fin），请求关闭连接之后进入close_wait，然而没有收到客户端的响应，可能由于客户端掉线了（如网络故障或者掉电），没有及时给予客户端回复造成问题。<br>或者由于客户端已经调用close(socket)退出，而服务端对其监测并断开连接，这种是服务端问题。<br>解决方法：一般是编程问题，可用keep_alive机制加以解决</p>
<h2 id="存在FIN-WAIT2的原因"><a href="#存在FIN-WAIT2的原因" class="headerlink" title="存在FIN_WAIT2的原因"></a>存在FIN_WAIT2的原因</h2><p>这个状态存在于主动发起断开请求的一端，如果服务器存在大量的这个状态，那么这个服务器就充当客户端的角色，如网络爬虫，出现的原因是由于客户端发起FIN请求结束连接之后，收到了服务端的应答之后进入FIN_WAIT2，之后就没收到服务端发送的FIN信号导致。<br>解决方法：可以配置FIN_WAIT2的时长，当超过时长后自动断开加以解决</p>
<h2 id="存在TIME-WAIT的原因"><a href="#存在TIME-WAIT的原因" class="headerlink" title="存在TIME_WAIT的原因"></a>存在TIME_WAIT的原因</h2><p>TIME_WAIT状态存在有两个原因：其一是响应服务端发送的FIN报文，保证服务端断开连接；其二是保证之前请求断开连接的请求，由于网络原因滞留在网络中，后续又到达了，导致后面重新建立的连接断开。<br>解决方法：设置TIME_WAIT状态的等待时间规避。即设置/proc/sys/net/ipv4下的相关参数</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-signal" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/20/signal/" class="article-date">
  	<time datetime="2017-02-20T00:32:41.000Z" itemprop="datePublished">2017-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/20/signal/">信号处理机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用信号"><span class="toc-text">常用信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号集"><span class="toc-text">信号集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号处理函数"><span class="toc-text">信号处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞信号"><span class="toc-text">阻塞信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#产生信号函数"><span class="toc-text">产生信号函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#睡眠函数及定时器"><span class="toc-text">睡眠函数及定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程与信号"><span class="toc-text">线程与信号</span></a></li></ol>
</div>

         
        <h2 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h2><p>信号定义在<signal.h>文件中，可以通过在shell下键入kill –l查看信号列表，或者man 7 signal查看说明。<br>    不能忽略的信号：SIGKILL及SIGSTOP 这两个信号是不能忽略的，即进程接收到这两个信号后，只能接受系统的默认处理，及终止进行。<br>    中断信号：SIGINT(ctrl+c触发)，SIGQIUT(ctrl+\触发)  </signal.h></p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>POSIX.1 定义数据类型sigset_t用于表示一个信号集，并且定义了以下的一组信号能对sigset_t结构体进行处理的函数，用于初始化及增删信号集：  </p>
<pre><code class="c"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;      <span class="comment">//清空信号集合set</span>
<span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;      <span class="comment">//将所有信号填充进set中</span>
<span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;    <span class="comment">//往set中添加信号signum</span>
<span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;    <span class="comment">//从set中移除信号signum</span>
<span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>; <span class="comment">//判断signnum是不是包含在set中</span>
<span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;  <span class="comment">//返回一信号集</span>
</code></pre>
<h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><ol>
<li><p>signal<br>其不能处理当正在执行信号处理函数期间又触发相同信号的情况。<br>对应的信号处理函数：void handler(int)</p>
</li>
<li><p>sigaction<br>其为signal函数的升级版，此函数取代了unix早期版本使用的signal函数。其原型如下：<br><code>int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact);</code><br>其中，signo是要检测或修改其具体动作的信号编号，act指针是需要设置的动作参数，oact参数用于存放该信号的上一个动作。其中struct sigation定义如下：  </p>
</li>
</ol>
<pre><code class="c"><span class="keyword">struct</span>  sigaction {
             <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);  <span class="comment">/* signal handler */</span>
             <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);
             <span class="keyword">sigset_t</span> sa_mask;               <span class="comment">/* signal mask to apply */</span>
             <span class="keyword">int</span>     sa_flags;               <span class="comment">/* see signal options below */</span>
     };
</code></pre>
<p>其中，sa_handler和sa_sigaction为信号处理函数。通常，使用sa_handler作为信号处理函数，如果在sigaction结构中使用SA_SIGINFO标志，则使用sa_sigaction作为信号处理程序为。有的系统把sa_handler和sa_sigaction用一个union表示（如mac os），所以应用只能一次使用这两个字段中的一个。sa_handler和sa_sigaction的原型如下：<br><code>void sa_handler(int)</code><br><code>void sa_sigaction (int iSignNum, siginfo_t *pSignInfo, void *pReserved);</code><br>对应的三个参数含义为：  </p>
<ul>
<li>iSignNum: 传入的信号</li>
<li>pSignInfo: 与信号相关的一些信息</li>
<li>pReserved: 保留<br>sa_mask字段为信号屏蔽字，其指出来在调用该信号捕捉程序之前，这一信号集要加到进程的信号屏蔽字中；仅当从信号捕捉函数返回时再将进程的信号屏蔽字恢复为原先值。<br>一旦对给定的信号设置一个动作，那么在调用sigaction显式地改变它之前，该设置就一直有效，这种方式与早期的不可靠信号机制不同，符合POSIX.1的要求。<br>  sa_flags指定对信号进行处理的各个选项，如SA_INTERRUPT(由信号中断的系统调用不自动重启)，SA_RESTART(信号中断的系统调用自动重启)，SA_SIGINFO(使用si_sigation处理函数，支持附加siginfo信息)<br>其中，几个常见的选项描述如下：   </li>
<li>SA_RESETHAND 处理完毕要捕捉的信号后，将自动撤消信号处理函数的注册，即必须再重新注册信号处理函数，才能继续处理接下来产生的信号。该选项不符合一般的信号处理流程，现已经被废弃。 </li>
<li>SA_NODEFER 在处理信号时，如果又发生了其它的信号，则立即进入其它信号的处理，等其它信号处理完毕后，再继续处理当前的信号，即递规地处理。如果sa_flags包含了该掩码，则结构体sigaction的sa_mask将无效！ </li>
<li>SA_RESTART 如果在发生信号时，程序正阻塞在某个系统调用，例如调用read()函数，则在处理完毕信号后，接着从阻塞的系统返回。该掩码符合普通的程序处理流程，所以一般来说，应该设置该掩码，否则信号处理完后，阻塞的系统调用将会返回失败！ </li>
<li>SA_SIGINFO 指示结构体的信号处理函数指针是哪个有效，如果sa_flags包含该掩码，则sa_sigactiion指针有效，否则是sa_handler指针有效。<h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2></li>
</ul>
<ol>
<li>sigaction阻塞<br>函数sigaction中设置的被阻塞信号集合只是针对于要处理的信号，例如  </li>
</ol>
<pre><code class="c"><span class="keyword">struct</span> sigaction act;
sigemptyset(&amp;act.sa_mask);
sigaddset(&amp;act.sa_mask,SIGQUIT);
sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>);
</code></pre>
<p>表示只有在处理信号SIGINT时，才阻塞信号SIGQUIT；  </p>
<ol>
<li>sigprocmask阻塞<br>函数sigprocmask是全程阻塞，在sigprocmask中设置了阻塞集合后，被阻塞的信号将不能再被信号处理函数捕捉，直到重新设置阻塞信号集合。其原型为：<br><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code><br>参数how的值为如下3者之一：  </li>
</ol>
<ul>
<li>SIG_BLOCK: 将参数2的信号集合添加到进程原有的阻塞信号集合中  </li>
<li>SIG_UNBLOCK: 从进程原有的阻塞信号集合移除参数2中包含的信号  </li>
<li>SIG_SET: 重新设置进程的阻塞信号集为参数2的信号集<br>参数set为阻塞信号集<br>参数oldset是传出参数，存放进程原有的信号集。  </li>
</ul>
<h2 id="产生信号函数"><a href="#产生信号函数" class="headerlink" title="产生信号函数"></a>产生信号函数</h2><ul>
<li>kill<br><code>int kill(pid_t pid, int sig);</code><br>用于将信号发送给进程或进程组.根据pid的参数设置，kill有以下4种不同的情况：<br>1、    pid &gt; 0     将信号发送给进程ID为pid的进程<br>2、    pid == 0    将信号发送给与发送进程同一个进程组的所有进程<br>3、    pid ==  -1  将信号发送给发送进程有权限向它们发送信号的所有进程<br>4、    pid &lt; 0     将信号发送给其进程组ID等于pid绝对值，而且发送进程具有权限向其发送信号的所有进程。<br>  信号编号为0的信号为空信号。如果signo为0，则kill仍执行正常的错误检查，但不发送信号，这常被用来确定一个特点进程是否仍然存在。如果向一个并不存在的进程发送信号，则kill返回-1，errno被设置为ESRH.<br>返回值：成功返回0，否则为-1  </li>
<li>raise<br><code>int raise(int signo);</code><br>等价于  kill(getpid(), signo) 即进程向自身发送信号。  </li>
<li>alarm<br><code>unsigned int alarm(unsigned int seconds);</code><br>seconds指定经过多少秒产生SIGALRM信号;alarm函数可以设置一个定时器，在将来的某个时刻该定时器会超时，产生SIGALRM信号，如果忽略或不捕捉该信号，则其默认动作是终止调用alarm函数的进程。<br>如果seconds值为0，则取消以前的闹钟时间，其余留值作为alarm函数的返回值。  </li>
<li>sigqueue<br>sigqueue也可以发送信号，并且能传递附加的信息<br><code>int sigqueue(pid_t pid, int sig, const union sigval value);</code><br>其中value为一整型与指针类型的联合体  </li>
</ul>
<pre><code class="c"><span class="keyword">union</span> sigval {
<span class="keyword">int</span> sival_int;
<span class="keyword">void</span> *sival_ptr;
};
</code></pre>
<p>由sigqueue函数发送的信号的第3个参数value的值，可以被进程的信号处理函数的第2个参数info-&gt;si_ptr接收到。<br>附注：<br>siginfo_t结构体可以通过man sigaction查看其定义。  </p>
<p>另外，pause函数可以使调用进程挂起直至捕获到一个信号。  </p>
<h2 id="睡眠函数及定时器"><a href="#睡眠函数及定时器" class="headerlink" title="睡眠函数及定时器"></a>睡眠函数及定时器</h2><ol>
<li>sleep类函数<br>sleep及usleep   前一个是以秒为单位，后一个是以毫秒为单位<br>nanosleep  和sleep类似，但提高了纳秒级的精度<br>其中sleep是采用信号机制进行处理的<br>用到的函数有：<br><code>unsigned int alarm(unsigned int seconds);</code><br><code>int pause();</code><br>因此：不要将alarm和sleep混用，不然会出现问题。而nanosleep则没有这个问题。  </li>
<li>定时器<br>Linux下的计时器 <sys time.h=""><br>Linux为每个进程维护3个计时器，分别是真实计时器、虚拟计时器和实用计时器。  </sys></li>
</ol>
<ul>
<li>真实计时器(ITIMER_REAL)计算的是程序运行的实际时间；</li>
<li>虚拟计时器(ITIMER_VITUAL)计算的是程序运行在用户态时所消耗的时间(可认为是实际时间减掉(系统调用和程序睡眠所消耗)的时间)；</li>
<li>实用计时器(ITIMER_PROF)计算的是程序处于用户态和处于内核态所消耗的时间之和。<br>发送的信号分别为SIGALRM，SIGVTALRM，SIGPROF<br>可结合setitimer函数来实现自己的定时器，但如果需要实现多个定时器的话，需要结果list结构来实现，可以参考<a href="http://www.cnblogs.com/cobbliu/p/3627448.html" target="_blank" rel="external">用setitimer实现多个定时器</a>  <h2 id="线程与信号"><a href="#线程与信号" class="headerlink" title="线程与信号"></a>线程与信号</h2>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着当某个线程改变了某个给定信号的相关处理行为时，所有线程都必须共享这个处理行为的改变，单个线程可以通过设置自己的信号屏蔽字来达到屏蔽各自不需要的信号。<br>线程中使用pthread_sigmask来设置线程的信号屏蔽字，其用法同sigprocmask，但其失败时返回错误码，不再像sigprocmask中那样设置errno并返回-1.<br>线程可以使用sigwait来等待一个或多个信号的出现。其原型如下：<br><code>int sigwait(const sigset_t * restrict set, int *restrict signop);</code><br>其中，set参数指定了线程等待的信号集；signop返回接收的信号。函数成功时返回0；错误时返回正的错误编号.<br>在sigwait返回前，sigwait将从进程中移除那些处于挂起等待的信号；如果具体实现支持信号排队，那么sigwait将会移除该信号的一个实例，其余的实例还要继续排队。<br>为了避免错误发生，线程在调用sigwait之前，必须阻塞(通过调用pthread_sigmask)那些它正在等待的信号。sig_wait会原子性地取消信号集地阻塞状态，直到接收到新的信号。在返回之前，sigwait将恢复线程的信号屏蔽字。这样不这样做，那么在线程完成对sigwait调用之前的时间窗中，信号就可以发送给该线程，从而造成sig_wait长时间阻塞不返回。<br>如果多个线程在sigwait的调用中等待同一个信号，那么在信号递送的时候，就只有一个线程可以从sigwait中返回（类似于条件变量的pthread_cond_wait）。如果这时即有sigwait调用，又有sigaction调用，那么将由操作心态决定是让sigwait返回，还是调用sigaction信号处理函数，但两者不会同时发生。<br>另外，可以通过调用pthread_kill将信号发送给指定pthread_t tid的线程，支持传递signo = 0的信号用来检查线程是否存在。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-signal/">Linux signal</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/08/Redis/" class="article-date">
  	<time datetime="2017-02-08T10:48:38.000Z" itemprop="datePublished">2017-02-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/08/Redis/">Redis讲解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis数据结构及操作"><span class="toc-text">Redis数据结构及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash"><span class="toc-text">hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-text">list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-text">set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted-sets"><span class="toc-text">sorted sets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis常用命令"><span class="toc-text">Redis常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#键值相关命令"><span class="toc-text">键值相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器相关命令"><span class="toc-text">服务器相关命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis高级实用命令"><span class="toc-text">Redis高级实用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安全性"><span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主从复制"><span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主从复制特点"><span class="toc-text">主从复制特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主从复制过程"><span class="toc-text">主从复制过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主从复制配置"><span class="toc-text">主从复制配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务控制"><span class="toc-text">事务控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#持久化机制"><span class="toc-text">持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#snapshotting方式"><span class="toc-text">snapshotting方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aof方式"><span class="toc-text">aof方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发布及订阅消息"><span class="toc-text">发布及订阅消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipeline-批量发送请求"><span class="toc-text">Pipeline 批量发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存的使用"><span class="toc-text">虚拟内存的使用</span></a></li></ol></li></ol>
</div>

         
        <h2 id="Redis数据结构及操作"><a href="#Redis数据结构及操作" class="headerlink" title="Redis数据结构及操作"></a>Redis数据结构及操作</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul>
<li>set/setnx</li>
<li>get</li>
<li>incr/incrby</li>
<li>decr/decrbys</li>
<li>setex: set value with expire time</li>
<li>setrange: 设置指定 key 的 value 值的子字符串。</li>
<li>getrange: 获取指定 key 的 value 值的子字符串。</li>
<li>mset/msetnx: 一次设置多个key的值</li>
<li>mget</li>
<li>getset:设置key的值，并返回key的旧值</li>
<li>append: 给指定 key 的字符串值追加 value,返回新字符串值的长度。</li>
<li>strlen: 取指定 key 的 value 值的长度。</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul>
<li>hset/hsetnx</li>
<li>hmset: 同时设置 hash 的多个 field</li>
<li>hget/hmget</li>
<li>hincrby</li>
<li>hexists: 测试指定 field 是否存在</li>
<li>hlen: 返回指定 hash 的 field 数量</li>
<li>hdel: 返回指定 hash 的 field 数量</li>
<li>hkeys: 返回 hash 的所有 field</li>
<li>hvals: 返回 hash 的所有 value</li>
<li><p>hgetall: 获取某个 hash 中全部的 filed 及 value</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list支持头部和尾部插入元素，也支持头尾删除元素，可以用作栈和队列  </p>
</li>
<li><p>lpush: left push, 在 key 对应 list 的头部添加字符串元素</p>
</li>
<li>lpop: lpop</li>
<li>lrang: 取某个范围的值</li>
<li>rpush: right push, 在 key 对应 list 的尾部添加字符串元素</li>
<li>linset: 在 key 对应 list 的特定位置之前或之后添加字符串元素</li>
<li>lset: 设置 list 中指定下标的元素值(下标从 0 开始)</li>
<li>lrem: 从 key 对应 list 中删除 count 个和 value 相同的元素。 count&gt;0 时,按从头到尾的顺序删除; count&lt;0 时,按从尾到头的顺序删除; count=0 时,删除全部</li>
<li>lpop: 从 list 的头部删除元素,并返回删除元素</li>
<li>rpop: 从 list 的尾部删除元素,并返回删除元素</li>
<li>rpoplpush: 从第一个 list 的尾部移除元素并添加到第二个 list 的头部,最后返回被移除的元素值,整个操 作是原子的.如果第一个 list 是空或者不存在返回 nil</li>
<li>lindex: 返回名称为 key 的 list 中 index 位置的元素</li>
<li>llen: 返回 key 对应 list 的长度</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Redis 的 set 是 string 类型的无序集合。set 元素最大可以包 (2 的 32 次方)个元素。set中的元素时唯一的  </p>
<ul>
<li>sadd: 向名称为 key 的 set 中添加元素</li>
<li>smembers: 查看set中的元素</li>
<li>srem: 删除名称为 key 的 set 中的元素 member</li>
<li>spop: 随机返回并删除名称为 key 的 set 中一个元素</li>
<li>sdiff: 返回所有给定 key 与第一个 key 的差集</li>
<li>sdiffstore: 返回所有给定 key 与第一个 key 的差集,并将结果存为另一个 key</li>
<li>sinter: 返回所有给定 key 的交集</li>
<li>sinterstore: 返回所有给定 key 的交集,并将结果存为另一个 key</li>
<li>sunion: 返回所有给定 key 的并集</li>
<li>sunionstore: 返回所有给定 key 的并集,并将结果存为另一个 key</li>
<li>smove: 从第一个 key 对应的 set 中移除 member 并添加到第二个对应 set 中</li>
<li>scard: 返回名称为 key 的 set 的元素个数</li>
<li>sismember: 测试 member 是否是名称为 key 的 set 的元素</li>
<li>srandmember: 随机返回名称为 key 的 set 的一个元素,但是不删除元素</li>
</ul>
<h3 id="sorted-sets"><a href="#sorted-sets" class="headerlink" title="sorted sets"></a>sorted sets</h3><p>sorted sets即有序的set，类似stl中的set概念。  </p>
<ul>
<li>zadd: 向名称为 key 的 zset 中添加元素 member,score 用于排序。如果该元素已经存在,则根据 score 更新该元素的顺序</li>
<li>zrange: 用于查看元素</li>
<li>zrem: 删除名称为 key 的 zset 中的元素 member</li>
<li>zincrby: 如果在名称为 key 的 zset 中已经存在元素 member,则该元素的 score 增加 increment;否则 向集合中添加该元素,其 score 的值为 increment</li>
<li>zrank: 返回名称为 key 的 zset 中 member 元素的排名(按 score 从小到大排序)即下标</li>
<li>zrevrank: 返回名称为 key 的 zset 中 member 元素的排名(按 score 从大到小排序)即下标</li>
<li>zrevrange: 返回名称为 key 的 zset(按 score 从大到小排序)中的 index 从 start 到 end 的所有元素</li>
<li>zrangebyscore: 返回集合中 score 在给定区间的元素</li>
<li>zcount: 返回集合中 score 在给定区间的数量</li>
<li>zcard: 返回集合中元素个数</li>
<li>zscore: 返回给定元素对应的 score</li>
<li>zremrangebyrank: 删除集合中排名在给定区间的元素</li>
<li>zremrangebyscore: 删除集合中 score 在给定区间的元素</li>
</ul>
<p>这些操作，只要你键入操作名后redis都会提示怎么用。如下图：  </p>
<p><img src="/img/redis_operate1.png" width="500" alt="图片名称" align="center">   </p>
<h2 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h2><h3 id="键值相关命令"><a href="#键值相关命令" class="headerlink" title="键值相关命令"></a>键值相关命令</h3><ul>
<li>keys: 返回满足给定 pattern 的所有 key</li>
<li>exists: 返回满足给定 pattern 的所有 key</li>
<li>del: 删除一个 key</li>
<li>expire: 设置一个 key 的过期时间(单位:秒)</li>
<li>select: 选择数据库</li>
<li>move: 将当前数据库中的 key 转移到其它数据库中</li>
<li>persist: 移除给定 key 的过期时间(将key设置为过期)</li>
<li>randomekey: 随机返回 key 空间的一个 key</li>
<li>rename: 重命名 key</li>
<li>type: 返回值的类型<h3 id="服务器相关命令"><a href="#服务器相关命令" class="headerlink" title="服务器相关命令"></a>服务器相关命令</h3></li>
<li>ping: 测试连接是否存活</li>
<li>echo: 在命令行打印一些内容</li>
<li>select: 选择数据库。Redis 数据库编号从 0~15,我们可以选择任意一个数据库来进行数据的存取。</li>
<li>quit: 退出连接</li>
<li>dbsize: 返回当前数据库中 key 的数目</li>
<li>info: 获取服务器的信息和统计</li>
<li>monitor: 实时转储收到的请求</li>
<li>config get: 获取服务器配置信息</li>
<li>flushdb: 删除当前选择数据库中的所有 key</li>
<li>flushall: 删除所有数据库中的所有 key</li>
</ul>
<h2 id="Redis高级实用命令"><a href="#Redis高级实用命令" class="headerlink" title="Redis高级实用命令"></a>Redis高级实用命令</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>在redis 配置文件中开启配置: <code>masterauth &lt;master-password&gt;</code>  </p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制特点"><a href="#主从复制特点" class="headerlink" title="主从复制特点"></a>主从复制特点</h4><ul>
<li>master 可以拥有多个 slave</li>
<li>多个 slave 可以连接同一个 master 外,还可以连接到其他 slave</li>
<li>主从复制不会阻塞 master,在同步数据时,master 可以继续处理 client 请求 </li>
<li>提高系统的伸缩性<h4 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h4>当配置好 slave 后,slave 与 master 建立连接,然后发送 sync 命令。无论是第一次连接还是重新连接,master 都会启动一个后台进程,将数据库快照保存到文件中,同时 master 主进 程会开始收集新的写命令并缓存。后台进程完成写文件后,master 就发送文件给 slave,slave 将文件保存到硬盘上,再加载到内存中,接着 master 就会把缓存的命令转发给 slave,后续 master 将收到的写命令发送给 slave。如果 master 同时收到多个 slave 发来的同步连接命令, master 只会启动一个进程来写数据库镜像,然后发送给所有的 slave。<h4 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h4></li>
</ul>
<ol>
<li>只需在slave的配置文件中添加<br><code># slaveof &lt;masterip&gt; &lt;masterport&gt;</code><br>如,<code>slaveof 192.168.1.1 6379</code></li>
<li>修改主从redis server的启动端口为不同的值，分别启动master和slave server。</li>
<li>分别连接主从 redis server进行操作，可见数据是同步的<br>tips：  </li>
</ol>
<ul>
<li>client端使用info命令，查看其输出的role值可知连接的是master还是slave。如下图：<br><img src="/img/redis_replication_info.png" width="300" alt="图片名称" align="center"><br>同时还有一个 master_link_status 用于标明主从是否异步,如果此值=up,说明同步正常;如果此值=down, 说明同步异步;<br>db0:keys=1,expires=0,avg_ttl=0, 用于说明数据库有几个 key,以及过期 key 的数量。</li>
</ul>
<h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><p>redis 对事务的支持目前还比较简单。redis 只能保证一个 client 发起的事务中的命令可以连 续的执行,而中间不会插入其他 client 的命令。 由于 redis 是单线程来处理所有 client 的请 求的所以做到这点是很容易的。一般情况下 redis 在接受到一个 client 发来的命令后会立即 处理并 返回处理结果,但是当一个 client 在一个连接中发出 multi 命令有,这个连接会进入 一个事务上下文,该连接后续的命令并不是立即执行,而是先放到一个队列中。当从此连接 受到 exec 命令后,redis 会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到 一起返回给 client.然后此连接就 结束事务上下文。  </p>
<ol>
<li>简单的事务控制<br>使用multi + command1 + … + commandN + exec, 可以将多个命令一起发送到redis server，然后一起返回结果。这记为一个事务  </li>
<li>取消事务<br>通过在执行exec前调用discard可以取消事务   </li>
<li>通过watch（乐观锁）控制事务<br>在多个session同时操作数据库中的数据时，可以用watch对操作字段加锁来实现事务同步。其操作原理如下        </li>
</ol>
<table>
<thead>
<tr>
<th>session 1</th>
<th>session 2     </th>
</tr>
</thead>
<tbody>
<tr>
<td>redis 127.0.0.1:6379&gt; get age</td>
<td></td>
</tr>
<tr>
<td>“10”</td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt; watch age</td>
<td></td>
</tr>
<tr>
<td>OK</td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt; multi</td>
<td></td>
</tr>
<tr>
<td>OK</td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>redis 127.0.0.1:6379&gt; set age 30 </td>
</tr>
<tr>
<td></td>
<td>OK</td>
</tr>
<tr>
<td></td>
<td>redis 127.0.0.1:6379&gt; get age </td>
</tr>
<tr>
<td></td>
<td>“30”</td>
</tr>
<tr>
<td></td>
<td>redis 127.0.0.1:6379&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt; set age 20</td>
<td></td>
</tr>
<tr>
<td>QUEUED</td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt; exec</td>
<td></td>
</tr>
<tr>
<td>(nil)</td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt; get age</td>
<td></td>
</tr>
<tr>
<td>“30”</td>
<td></td>
</tr>
<tr>
<td>redis 127.0.0.1:6379&gt;</td>
<td></td>
</tr>
</tbody>
</table>
<p>从以上实例可以看到在<br>第一步,Session 1 还没有来得及对 age 的值进行修改<br>第二步,Session 2 已经将 age 的值设为 30<br>第三步,Session 1 希望将 age 的值设为 20,但结果一执行返回是 nil,说明执行失败,之后 我们再取一下 age 的值是 30,这是由于 Session 1 中对 age 加了乐观锁导致的。  </p>
<p><strong>redis 的事务实现是如此简单,当然会存在一些问题</strong><br>第一个问题是 redis 只能保证事务的每 个命令连续执行,但是如果事务中的一个命令失败了,并不回滚其他命令,比如使用的命令类型不匹配。<br>如： </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">age</span>   </div><div class="line">"30"  <span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">name</span>"<span class="selector-tag">HongWan</span>"<span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">multi</span><span class="selector-tag">OK</span><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">incr</span> <span class="selector-tag">age</span><span class="selector-tag">QUEUED</span><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">incr</span> <span class="selector-tag">name</span><span class="selector-tag">QUEUED</span><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">exec</span>1) (<span class="selector-tag">integer</span>) 312) (<span class="selector-tag">error</span>) <span class="selector-tag">ERR</span> <span class="selector-tag">value</span> <span class="selector-tag">is</span> <span class="selector-tag">not</span> <span class="selector-tag">an</span> <span class="selector-tag">integer</span> <span class="selector-tag">or</span> <span class="selector-tag">out</span> <span class="selector-tag">of</span> <span class="selector-tag">range</span>   </div><div class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">age</span>"31"<span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">name</span> "<span class="selector-tag">HongWan</span>"<span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt;</div></pre></td></tr></table></figure>
<p>从以上操作我们可以看出由于name是非数字，不支持incr操作，导致事务失败了，但age却成功加1。  <strong>不过我现在用的redis 3.2.7版本已经没有这个问题。</strong></p>
<h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>redis 是一个支持持久化的内存数据库,也就是说 redis 需要经常将内存中的数据同步到磁盘 来保证持久化。redis 支持两种持久化方式,一种是 Snapshotting(快照)也是默认方式,另 一种是 Append-only file(缩写 aof)的方式。下面分别介绍:</p>
<h4 id="snapshotting方式"><a href="#snapshotting方式" class="headerlink" title="snapshotting方式"></a>snapshotting方式</h4><p>这是默认的持久化方式。这种方式就是将内存中数据以snapshot方式写入到二进制文件中，默认的文件名为dump.rdb。可以通过配置自动做快照持久化的方式。redis可以配置在n秒内如果超过m个key被修改就自动做snapshot。其默认的配置如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">################################ SNAPSHOTTING  ################################</div><div class="line">save <span class="number">900</span> <span class="number">1</span>   #<span class="number">900</span> 秒内如果超过 <span class="number">1</span> 个 <span class="type">key</span> 被修改,则发起快照保存</div><div class="line">save <span class="number">300</span> <span class="number">10</span>  #<span class="number">300</span> 秒内容如超过 <span class="number">10</span> 个 <span class="type">key</span> 被修改,则发起快照保存</div><div class="line">save <span class="number">60</span> <span class="number">10000</span></div></pre></td></tr></table></figure>
<p>snapshot过程如下：  </p>
<ol>
<li>redis调用fork，创建子进程</li>
<li>父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由写时拷贝原理，父子进程共享相同的物理页面。当父进程需要写操作时会重新创建副本，故子进程地址空间内的数据是fork时刻整个数据库的一个快照。</li>
<li>当子进程将快照写入临时文件完毕后，用临时文件替换之前的快照文件，然后子进程退出。<br>p.s: redis也支持使用save或bgsave命令通知redis做一次快照操作。不过save操作是在主进程中保存快照的，这是会阻塞所有的client请求，不推荐使用。<br>redis的快照文件为dump.rdb</li>
</ol>
<h3 id="aof方式"><a href="#aof方式" class="headerlink" title="aof方式"></a>aof方式</h3><p>由于快照是在一定间隔时间做一次的，因此如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。如果要求应用不能丢失任何修改的话，可以采用aof持久化方式。<br>aof(append-only file)比snapshot具有更好的持久化性，当使用aof方式时，redis会将收到的命令通过write函数追加到文件中(默认是appendonly.aof)。当redis重启时会通过重新执行文件中保存的写命令来重建整个数据库的内容。<br>由于os会在内核中缓存write做的修改，所以aof文件可能不是立即写到磁盘上，也存在丢失部分修改的情况。不过我们可以通过配置文件告诉redis通过fsync函数强制写入磁盘的时机。aof方式可以通过配置<code>appendonly yes</code>启用，其有进行sync的时间有如下三种方式：  </p>
<ul>
<li>appendfsync always    //收到命令立即写入磁盘，最慢，但是持久性最好</li>
<li>appendfsync everysec  //默认方式，每秒钟写入磁盘一次，是持久性和性能的折中</li>
<li>appendfsync no        //由操作系统选择，性能最优，但持久性没保证</li>
</ul>
<p>aof方式的一个问题是持久化文件会越变越大(因为其为保存了每一条命令，如执行<code>incr var</code>100次，则要保存100条，但其实恢复状态只需set var var 100即可[假设var初值为0])。为了压缩aof的持久化文件。redis提 供了 bgrewriteaof 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令 的方式保存到临时文件中,最后替换原来的文件。具体过程如下：  </p>
<ol>
<li>redis 调用 fork ,现在有父子两个进程 </li>
<li>子进程根据内存中的数据库快照,往临时文件中写入重建数据库状态的命令</li>
<li>父进程继续处理 client 请求,除了把写命令写入到原来的 aof 文件中。同时把收到的写命 令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。 </li>
<li>当子进程把快照内容写入已命令方式写到临时文件中后,子进程发信号通知父进程。然 后父进程把缓存的写命令也写入到临时文件。</li>
<li>现在父进程可以使用临时文件替换老的 aof 文件,并重命名,后面收到的写命令也开始 往新的 aof 文件中追加。</li>
</ol>
<h3 id="发布及订阅消息"><a href="#发布及订阅消息" class="headerlink" title="发布及订阅消息"></a>发布及订阅消息</h3><p>redis 作为一个 pub/sub 的 server,在订阅者 和发布者之间起到了消息路由的功能。订阅者可以通过 subscribe 和 psubscribe 命令向 redis server 订阅自己感兴趣的消息类型,redis 将消息类型称为通道(channel)。当发布者通过 publish命令向redis server发送特定类型的消息时, 订阅该消息类型的全部client都会收到此消息。这里消息的传递是多对多的。一个 client 可以订阅多个 channel,也可以向多个 channel 发送消息。redis提供相关的命令如下：</p>
<ul>
<li>SUBSCRIBE channel [channel …]: 用于订阅某个频道或者多个频道 </li>
<li>PUBLISH channel message: 用于发布频道信息</li>
<li>PSUBSCRIBE pattern [pattern …]: 批量订阅满足某一pattern的频道，如tv*，表示以tv开头的频道</li>
</ul>
<h3 id="Pipeline-批量发送请求"><a href="#Pipeline-批量发送请求" class="headerlink" title="Pipeline 批量发送请求"></a>Pipeline 批量发送请求</h3><p>由于redis server处理命令的速度很快，如果客户端命令多的话，可以一起打包发送给server，从而减少大部分的网络延迟，达到提高性能的目的。我们可以利用 pipeline 的方式 从 client 打包多条命令一起发出,不需要等待单条命令的响应返回,而 redis 服务端会处理 完多条命令后会将多条命令的处理结果打包到一起返回给客户端。同时，打包的命令越多,缓存消耗内存也越多。所以并不是打包的命令 越多越好。具体多少合适需要根据具体情况测试。  </p>
<p>java代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//usepipeline</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usePipeline</span><span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123;ConnectionSpec spec = DefaultConnectionSpec.newSpec(<span class="string">"192.168.115.170"</span>, <span class="number">6379</span>, <span class="number">0</span>, <span class="keyword">null</span>); JRedis jredis = <span class="keyword">new</span> JRedisPipelineService(spec);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; jredis.incr(<span class="string">"test2"</span>);&#125;jredis.quit();&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;&#125;</div></pre></td></tr></table></figure>
<pre><code class="java"><span class="comment">//withoutPipleline</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">withoutPipeline</span><span class="params">()</span> </span>{
<span class="keyword">try</span> {
JRedis jredis = <span class="keyword">new</span> JRedisClient(<span class="string">"192.168.115.170"</span>, <span class="number">6379</span>);
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) { jredis.incr(<span class="string">"test2"</span>);}
jredis.quit();
} <span class="keyword">catch</span> (Exception e) {
}
}
</code></pre>
<h3 id="虚拟内存的使用"><a href="#虚拟内存的使用" class="headerlink" title="虚拟内存的使用"></a>虚拟内存的使用</h3><p>redis实现了自己的虚拟内存管理。redis 没有使用操作系统提供的虚拟内存机制而是自己在实现了自己的虚拟内存机制,主要的理由有两点:</p>
<ol>
<li>操作系统的虚拟内存是已 4k 页面为最小单位进行交换的。而 redis 的大多数对象都远小 于 4k,所以一个操作系统页面上可能有多个 redis 对象。另外 redis 的集合对象类型如 list,set 可能存在与多个操作系统页面上。最终可能造成只有 10%key 被经常访问,但是所有操作系 统页面都会被操作系统认为是活跃的,这样只有内存真正耗尽时操作系统才会交换页面。</li>
<li>相比于操作系统的交换方式,redis 可以将被交换到磁盘的对象进行压缩,保存到磁盘的对 象可以去除指针和对象元数据信息,一般压缩后的对象会比内存中的对象小 10 倍,这样 redis 的虚拟内存会比操作系统虚拟内存能少做很多 io 操作</li>
</ol>
<p><strong><em>参考资料</em></strong>：《redis实战》</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/coding/">编程</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 chenhy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: /
	}
</script>
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>